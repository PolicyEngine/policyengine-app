import { optimiseHousehold } from "../api/variables";
import { defaultYear } from "./constants";

export function getReproducibilityCodeBlock(
  type,
  metadata,
  policy,
  region,
  year,
  householdInput = null,
  earningVariation = null,
) {
  // Return a series of lines, concatted into an array,
  // generated by sub-functions

  return [
    ...getHeaderCode(type, metadata, policy),
    ...getBaselineCode(policy, metadata),
    ...getReformCode(policy, metadata),
    ...getSituationCode(
      type,
      metadata,
      policy,
      year,
      householdInput,
      earningVariation,
    ),
    ...getImplementationCode(type, region, year, policy),
  ];
}

export function getHeaderCode(type, metadata, policy) {
  let lines = [];

  // Add lines depending upon type of block
  if (type === "household") {
    lines.push("from " + metadata.package + " import Simulation");
  } else {
    lines.push("from " + metadata.package + " import Microsimulation");
  }

  // If either baseline or reform is custom, add the following Python imports
  if (
    Object.keys(policy.reform.data).length > 0 ||
    Object.keys(policy.baseline.data).length > 0
  ) {
    lines.push("from policyengine_core.reforms import Reform");
  }

  return lines;
}

export function getBaselineCode(policy, metadata) {
  if (
    !policy?.baseline?.data ||
    Object.keys(policy.baseline.data).length === 0
  ) {
    return [];
  }
  let json_str = JSON.stringify(policy.baseline.data, null, 2);
  json_str = sanitizeStringToPython(json_str);
  let lines = [""].concat(json_str.split("\n"));
  lines[1] = "baseline = Reform.from_dict({" + lines[0];
  lines[lines.length - 1] =
    lines[lines.length - 1] + ', country_id="' + metadata.countryId + '")';
  return lines;
}

export function getReformCode(policy, metadata) {
  if (!policy?.baseline?.data || Object.keys(policy.reform.data).length === 0) {
    return [];
  }
  let json_str = JSON.stringify(policy.reform.data, null, 2);
  json_str = sanitizeStringToPython(json_str);
  let lines = [""].concat(json_str.split("\n"));
  lines[1] = "reform = Reform.from_dict({" + lines[0];
  lines[lines.length - 1] =
    lines[lines.length - 1] + ', country_id="' + metadata.countryId + '")';
  return lines;
}

export function getSituationCode(
  type,
  metadata,
  policy,
  year,
  householdInput,
  earningVariation,
) {
  if (type !== "household") {
    return [];
  }

  let householdInputCopy = JSON.parse(
    JSON.stringify(optimiseHousehold(householdInput, metadata, true)),
  );

  for (const entityPlural of Object.keys(householdInputCopy)) {
    for (const entity of Object.keys(householdInputCopy[entityPlural])) {
      for (const variable of Object.keys(
        householdInputCopy[entityPlural][entity],
      )) {
        if (variable !== "members") {
          if (
            householdInputCopy[entityPlural][entity][variable][year] === null
          ) {
            delete householdInputCopy[entityPlural][entity][variable];
          }
        }
        if (earningVariation && variable === "employment_income") {
          delete householdInputCopy[entityPlural][entity][variable];
        }
      }
    }
  }

  if (earningVariation) {
    householdInputCopy["axes"] = [
      [{ name: "employment_income", count: 200, min: 0, max: 200_000 }],
    ];
  }

  let householdJson = JSON.stringify(householdInputCopy, null, 2);
  // It's Python-safe, so we need to make true -> True and false -> False and null -> None
  householdJson = sanitizeStringToPython(householdJson);

  let lines = [
    "",
    "",
    "situation = " + householdJson,
    "",
    "simulation = Simulation(",
  ];

  if (Object.keys(policy.reform.data).length) {
    lines.push("    reform=reform,");
  }

  lines = lines.concat([
    "    situation=situation,",
    ")",
    "",
    `output = simulation.calculate("household_net_income", ${year})`,
    "print(output)",
  ]);

  return lines;
}

export function getImplementationCode(type, region, timePeriod, policy) {
  if (type !== "policy") {
    return [];
  }

  const hasBaseline = Object.keys(policy?.baseline?.data).length > 0;
  const hasReform = Object.keys(policy?.reform?.data).length > 0;
  const hasDatasetSpecified = region === "enhanced_us";
  const dataset = hasDatasetSpecified ? '"enhanced_cps_2022"' : "";

  return [
    "",
    "",
    `baseline = Microsimulation(${
      hasDatasetSpecified && hasBaseline
        ? `reform=baseline, dataset=${dataset}`
        : hasBaseline
          ? `reform=baseline`
          : hasDatasetSpecified
            ? `dataset=${dataset}`
            : ""
    })`,
    `reformed = Microsimulation(${
      hasDatasetSpecified && hasReform
        ? `reform=reform, dataset=${dataset}`
        : hasReform
          ? `reform=reform`
          : hasDatasetSpecified
            ? `dataset=${dataset}`
            : ""
    })`,
    `baseline_person = baseline.calculate("household_net_income", period=${timePeriod || defaultYear}, map_to="person")`,
    `reformed_person = reformed.calculate("household_net_income", period=${timePeriod || defaultYear}, map_to="person")`,
    "difference_person = reformed_person - baseline_person",
  ];
}

export function getStartEndDates(policy) {
  let earliestStart = null;
  let latestEnd = null;

  for (const parameter of Object.keys(policy.reform.data)) {
    for (const instant of Object.keys(policy.reform.data[parameter])) {
      const [start, end] = instant.split(".");
      if (!earliestStart || Date.parse(start) < Date.parse(earliestStart)) {
        earliestStart = start;
      }
      if (!latestEnd || Date.parse(end) > Date.parse(latestEnd)) {
        latestEnd = end;
      }
    }
  }

  return {
    earliestStart: earliestStart,
    latestEnd: latestEnd,
  };
}

/**
 * Transforms a parameter name with a number in the name
 * into valid Python syntax
 * @param {String} paramName
 * @returns {String} the transformed name
 */
export function transformNumberedParamName(paramName) {
  // Break the paramName into an array of dot-separated
  // components
  const NAME_ACCESSOR = ".";
  const nameParts = paramName.split(NAME_ACCESSOR);

  // Isolate number within the array and reformat
  const sanitizedParts = nameParts.map((word) => {
    if (Number(word)) {
      word = `children["${word}"]`;
    }
    return word;
  });

  // Re-join the array into a string and return
  return sanitizedParts.join(".");
}

/**
 * Determines whether a parameter name (a ParameterNode
 * object from a country package, accessed via country metadata)
 * contains a number in the name, making it impossible to access
 * through standard Python dot notation syntax
 * @param {String} paramName
 * @returns {Boolean} "true" if parameter name contains a number
 * (as defined as a String, successfully casted to a Number),
 * otherwise false
 */
export function doesParamNameContainNumber(paramName) {
  const JOIN_TOKEN = ".";

  // Take the param name and break it by its joining token
  const paramNameArray = paramName.split(JOIN_TOKEN);

  // Iterate over the resulting array
  for (const name of paramNameArray) {
    if (Number(name)) {
      return true;
    }
  }

  return false;
}

/**
 * Utility function to sanitize a string and ensure that it's valid Python;
 * currently converts JS 'null', 'true', and 'false' to Python
 * 'None', 'True', and 'False'
 * @param {String} string
 * @returns {String}
 */
export function sanitizeStringToPython(string) {
  return string
    .replace(/true/g, "True")
    .replace(/false/g, "False")
    .replace(/null/g, "None");
}
